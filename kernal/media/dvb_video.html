<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 11. DVB Video Device</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="LINUX MEDIA INFRASTRUCTURE API" /><link rel="up" href="dvbapi.html" title="Part II. LINUX DVB API" /><link rel="prev" href="dmx_fcalls.html" title="Demux Function Calls" /><link rel="next" href="video_function_calls.html" title="Video Function Calls" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 11. DVB Video Device</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="dmx_fcalls.html">Prev</a> </td><th width="60%" align="center">Part II. LINUX DVB API</th><td width="20%" align="right"> <a accesskey="n" href="video_function_calls.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="dvb_video"></a>Chapter 11. DVB Video Device</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="dvb_video.html#video_types">Video Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="dvb_video.html#video_format_t">video_format_t</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_display_format_t">video_display_format_t</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_stream_source">video stream source</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_play_state">video play state</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_event">struct video_event</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_status">struct video_status</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_still_picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_system">video system</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_spu">video SPU</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_spu_palette">video SPU palette</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_navi_pack">video NAVI pack</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_attributes">video attributes</a></span></dt></dl></dd><dt><span class="section"><a href="video_function_calls.html">Video Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="video_function_calls.html#video_fopen">open()</a></span></dt><dt><span class="section"><a href="video_function_calls.html#video_fclose">close()</a></span></dt><dt><span class="section"><a href="video_function_calls.html#video_fwrite">write()</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65632876">VIDEO_STOP</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65644388">VIDEO_PLAY</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65652916">VIDEO_FREEZE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65661764">VIDEO_CONTINUE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65670356">VIDEO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65680212">VIDEO_SET_BLANK</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65691828">VIDEO_GET_STATUS</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65702692">VIDEO_GET_EVENT</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65715908">VIDEO_SET_DISPLAY_FORMAT</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65726692">VIDEO_STILLPICTURE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65737636">VIDEO_FAST_FORWARD</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65749484">VIDEO_SLOWMOTION</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65761340">VIDEO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65771164">VIDEO_SET_ID</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65781852">VIDEO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65789252">VIDEO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65798996">VIDEO_SET_FORMAT</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65808716">VIDEO_SET_SYSTEM</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65818500">VIDEO_SET_HIGHLIGHT</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65828228">VIDEO_SET_SPU</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65838028">VIDEO_SET_SPU_PALETTE</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65847796">VIDEO_GET_NAVI</a></span></dt><dt><span class="section"><a href="video_function_calls.html#idp65857620">VIDEO_SET_ATTRIBUTES</a></span></dt></dl></dd></dl></div><p>The DVB video device controls the MPEG2 video decoder of the DVB hardware. It
can be accessed through <span class="tt">/dev/dvb/adapter0/video0</span>. Data types and and
ioctl definitions can be accessed by including <span class="tt">linux/dvb/video.h</span> in your
application.
</p><p>Note that the DVB video device only controls decoding of the MPEG video stream, not
its presentation on the TV or computer screen. On PCs this is typically handled by an
associated video4linux device, e.g. <span class="tt">/dev/video</span>, which allows scaling and defining output
windows.
</p><p>Some DVB cards don’t have their own MPEG decoder, which results in the omission of
the audio and video device as well as the video4linux device.
</p><p>The ioctls that deal with SPUs (sub picture units) and navigation packets are only
supported on some MPEG decoders made for DVD playback.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="video_types"></a>Video Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="dvb_video.html#video_format_t">video_format_t</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_display_format_t">video_display_format_t</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_stream_source">video stream source</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_play_state">video play state</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_event">struct video_event</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_status">struct video_status</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_still_picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_system">video system</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_spu">video SPU</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_spu_palette">video SPU palette</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_navi_pack">video NAVI pack</a></span></dt><dt><span class="section"><a href="dvb_video.html#video_attributes">video attributes</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_format_t"></a>video_format_t</h3></div></div></div><p>The <span class="tt">video_format_t</span> data type defined by
</p><pre class="programlisting">
 typedef enum {
	 VIDEO_FORMAT_4_3,
	 VIDEO_FORMAT_16_9
 } video_format_t;
</pre><p>is used in the VIDEO_SET_FORMAT function (??) to tell the driver which aspect ratio
the output hardware (e.g. TV) has. It is also used in the data structures video_status
(??) returned by VIDEO_GET_STATUS (??) and video_event (??) returned by
VIDEO_GET_EVENT (??) which report about the display format of the current video
stream.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_display_format_t"></a>video_display_format_t</h3></div></div></div><p>In case the display format of the video stream and of the display hardware differ the
application has to specify how to handle the cropping of the picture. This can be done using
the VIDEO_SET_DISPLAY_FORMAT call (??) which accepts
</p><pre class="programlisting">
 typedef enum {
	 VIDEO_PAN_SCAN,
	 VIDEO_LETTER_BOX,
	 VIDEO_CENTER_CUT_OUT
 } video_display_format_t;
</pre><p>as argument.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_stream_source"></a>video stream source</h3></div></div></div><p>The video stream source is set through the VIDEO_SELECT_SOURCE call and can take
the following values, depending on whether we are replaying from an internal (demuxer) or
external (user write) source.
</p><pre class="programlisting">
 typedef enum {
	 VIDEO_SOURCE_DEMUX,
	 VIDEO_SOURCE_MEMORY
 } video_stream_source_t;
</pre><p>VIDEO_SOURCE_DEMUX selects the demultiplexer (fed either by the frontend or the
DVR device) as the source of the video stream. If VIDEO_SOURCE_MEMORY
is selected the stream comes from the application through the <span class="tt">write()</span> system
call.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_play_state"></a>video play state</h3></div></div></div><p>The following values can be returned by the VIDEO_GET_STATUS call representing the
state of video playback.
</p><pre class="programlisting">
 typedef enum {
	 VIDEO_STOPPED,
	 VIDEO_PLAYING,
	 VIDEO_FREEZED
 } video_play_state_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_event"></a>struct video_event</h3></div></div></div><p>The following is the structure of a video event as it is returned by the VIDEO_GET_EVENT
call.
</p><pre class="programlisting">
 struct video_event {
	 int32_t type;
	 time_t timestamp;
	 union {
		 video_format_t video_format;
	 } u;
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_status"></a>struct video_status</h3></div></div></div><p>The VIDEO_GET_STATUS call returns the following structure informing about various
states of the playback operation.
</p><pre class="programlisting">
 struct video_status {
	 boolean video_blank;
	 video_play_state_t play_state;
	 video_stream_source_t stream_source;
	 video_format_t video_format;
	 video_displayformat_t display_format;
 };
</pre><p>If video_blank is set video will be blanked out if the channel is changed or if playback is
stopped. Otherwise, the last picture will be displayed. play_state indicates if the video is
currently frozen, stopped, or being played back. The stream_source corresponds to the seleted
source for the video stream. It can come either from the demultiplexer or from memory.
The video_format indicates the aspect ratio (one of 4:3 or 16:9) of the currently
played video stream. Finally, display_format corresponds to the selected cropping
mode in case the source video format is not the same as the format of the output
device.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_still_picture"></a>struct video_still_picture</h3></div></div></div><p>An I-frame displayed via the VIDEO_STILLPICTURE call is passed on within the
following structure.
</p><pre class="programlisting">
 /⋆ pointer to and size of a single iframe in memory ⋆/
 struct video_still_picture {
	 char ⋆iFrame;
	 int32_t size;
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_caps"></a>video capabilities</h3></div></div></div><p>A call to VIDEO_GET_CAPABILITIES returns an unsigned integer with the following
bits set according to the hardwares capabilities.
</p><pre class="programlisting">
 /⋆ bit definitions for capabilities: ⋆/
 /⋆ can the hardware decode MPEG1 and/or MPEG2? ⋆/
 #define VIDEO_CAP_MPEG1   1
 #define VIDEO_CAP_MPEG2   2
 /⋆ can you send a system and/or program stream to video device?
    (you still have to open the video and the audio device but only
     send the stream to the video device) ⋆/
 #define VIDEO_CAP_SYS     4
 #define VIDEO_CAP_PROG    8
 /⋆ can the driver also handle SPU, NAVI and CSS encoded data?
    (CSS API is not present yet) ⋆/
 #define VIDEO_CAP_SPU    16
 #define VIDEO_CAP_NAVI   32
 #define VIDEO_CAP_CSS    64
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_system"></a>video system</h3></div></div></div><p>A call to VIDEO_SET_SYSTEM sets the desired video system for TV output. The
following system types can be set:
</p><pre class="programlisting">
 typedef enum {
	  VIDEO_SYSTEM_PAL,
	  VIDEO_SYSTEM_NTSC,
	  VIDEO_SYSTEM_PALN,
	  VIDEO_SYSTEM_PALNc,
	  VIDEO_SYSTEM_PALM,
	  VIDEO_SYSTEM_NTSC60,
	  VIDEO_SYSTEM_PAL60,
	  VIDEO_SYSTEM_PALM60
 } video_system_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_highlight"></a>struct video_highlight</h3></div></div></div><p>Calling the ioctl VIDEO_SET_HIGHLIGHTS posts the SPU highlight information. The
call expects the following format for that information:
</p><pre class="programlisting">
 typedef
 struct video_highlight {
	 boolean active;      /⋆    1=show highlight, 0=hide highlight ⋆/
	 uint8_t contrast1;   /⋆    7- 4  Pattern pixel contrast ⋆/
			      /⋆    3- 0  Background pixel contrast ⋆/
	 uint8_t contrast2;   /⋆    7- 4  Emphasis pixel-2 contrast ⋆/
			      /⋆    3- 0  Emphasis pixel-1 contrast ⋆/
	 uint8_t color1;      /⋆    7- 4  Pattern pixel color ⋆/
			      /⋆    3- 0  Background pixel color ⋆/
	 uint8_t color2;      /⋆    7- 4  Emphasis pixel-2 color ⋆/
			      /⋆    3- 0  Emphasis pixel-1 color ⋆/
	 uint32_t ypos;       /⋆   23-22  auto action mode ⋆/
			      /⋆   21-12  start y ⋆/
			      /⋆    9- 0  end y ⋆/
	 uint32_t xpos;       /⋆   23-22  button color number ⋆/
			      /⋆   21-12  start x ⋆/
			      /⋆    9- 0  end x ⋆/
 } video_highlight_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_spu"></a>video SPU</h3></div></div></div><p>Calling VIDEO_SET_SPU deactivates or activates SPU decoding, according to the
following format:
</p><pre class="programlisting">
 typedef
 struct video_spu {
	 boolean active;
	 int stream_id;
 } video_spu_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_spu_palette"></a>video SPU palette</h3></div></div></div><p>The following structure is used to set the SPU palette by calling VIDEO_SPU_PALETTE:
</p><pre class="programlisting">
 typedef
 struct video_spu_palette{
	 int length;
	 uint8_t ⋆palette;
 } video_spu_palette_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_navi_pack"></a>video NAVI pack</h3></div></div></div><p>In order to get the navigational data the following structure has to be passed to the ioctl
VIDEO_GET_NAVI:
</p><pre class="programlisting">
 typedef
 struct video_navi_pack{
	 int length;         /⋆ 0 ... 1024 ⋆/
	 uint8_t data[1024];
 } video_navi_pack_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="video_attributes"></a>video attributes</h3></div></div></div><p>The following attributes can be set by a call to VIDEO_SET_ATTRIBUTES:
</p><pre class="programlisting">
 typedef uint16_t video_attributes_t;
 /⋆   bits: descr. ⋆/
 /⋆   15-14 Video compression mode (0=MPEG-1, 1=MPEG-2) ⋆/
 /⋆   13-12 TV system (0=525/60, 1=625/50) ⋆/
 /⋆   11-10 Aspect ratio (0=4:3, 3=16:9) ⋆/
 /⋆    9- 8 permitted display mode on 4:3 monitor (0=both, 1=only pan-sca ⋆/
 /⋆    7    line 21-1 data present in GOP (1=yes, 0=no) ⋆/
 /⋆    6    line 21-2 data present in GOP (1=yes, 0=no) ⋆/
 /⋆    5- 3 source resolution (0=720x480/576, 1=704x480/576, 2=352x480/57 ⋆/
 /⋆    2    source letterboxed (1=yes, 0=no) ⋆/
 /⋆    0    film/camera mode (0=camera, 1=film (625/50 only)) ⋆/
</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="dmx_fcalls.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="dvbapi.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="video_function_calls.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Demux Function Calls </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Video Function Calls</td></tr></table></div></body></html>