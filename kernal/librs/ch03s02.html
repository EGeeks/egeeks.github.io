<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Encoding</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Reed-Solomon Library Programming Interface" /><link rel="up" href="usage.html" title="Chapter 3. Usage" /><link rel="prev" href="usage.html" title="Chapter 3. Usage" /><link rel="next" href="ch03s03.html" title="Decoding" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Encoding</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="usage.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Usage</th><td width="20%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp31414268"></a>Encoding</h2></div></div></div><p>
			The encoder calculates the Reed-Solomon code over
			the given data length and stores the result in 
			the parity buffer. Note that the parity buffer must
			be initialized before calling the encoder.
		</p><p>
			The expanded data can be inverted on the fly by
			providing a non-zero inversion mask. The expanded data is
			XOR'ed with the mask. This is used e.g. for FLASH
			ECC, where the all 0xFF is inverted to an all 0x00.
			The Reed-Solomon code for all 0x00 is all 0x00. The
			code is inverted before storing to FLASH so it is 0xFF
			too. This prevents that reading from an erased FLASH
			results in ECC errors.
		</p><p>
			The databytes are expanded to the given symbol size
			on the fly. There is no support for encoding continuous
			bitstreams with a symbol size != 8 at the moment. If
			it is necessary it should be not a big deal to implement
			such functionality.
		</p><pre class="programlisting">
/* Parity buffer. Size = number of roots */
uint16_t par[6];
/* Initialize the parity buffer */
memset(par, 0, sizeof(par));
/* Encode 512 byte in data8. Store parity in buffer par */
encode_rs8 (rs_decoder, data8, 512, par, 0);
		</pre></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="usage.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="usage.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Usage </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Decoding</td></tr></table></div></body></html>